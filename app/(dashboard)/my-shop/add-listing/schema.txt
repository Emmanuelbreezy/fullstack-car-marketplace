type PhoneField = string;
type NumberField = number;
type MultiselectField = string[];
type SelectField = string

// Define schema for photos separately
  const imageUrlsSchema = z.object({
    imageUrls: z
      .array(z.string())
      .min(3, { message: "At least 3 photo is required" }),
  });

  const fieldTypeSchemaMap: Record<string, z.ZodSchema> = {
    number: z.string().trim().optional() as z.ZodSchema<NumberField>,
    phone: z
      .string()
      .refine(isValidPhoneNumber, { message: "Invalid phone number" })
      .optional() as z.ZodSchema<PhoneField>,
    multiselect: z
      .array(z.string())
      .optional() as z.ZodSchema<MultiselectField>,
    select: z.string().optional() as z.ZodSchema<SelectField>,
  };

  // Use the union types in your dynamicFieldsSchema
  const dynamicFieldsSchema = z.object(
    addListingFields.reduce((schema, field) => {
      let fieldSchema =
        fieldTypeSchemaMap[field.fieldType] || z.string().optional();

      if (field.required) {
        fieldSchema =
          fieldSchema instanceof z.ZodArray
            ? fieldSchema.min(1, { message: `${field.label} is required` })
            : fieldSchema.refine((value) => !!value, {
                message: `${field.label} is required`,
              });
      }
      schema[field.name] = fieldSchema;
      return schema;
    }, {} as Record<string, z.ZodSchema>)
  );

  // Merge the two schemas
  const formSchema = dynamicFieldsSchema.merge(imageUrlsSchema);